##  ------------------------------------------------------------------------  ##
##                               Bash Options                                 ##
##  ------------------------------------------------------------------------  ##

TZ='Europe/Kiev'; export TZ;

##  ------------------------------------------------------------------------  ##
##                              Some settings                                 ##
##  ------------------------------------------------------------------------  ##

#set -o nounset     # These  two options are useful for debugging.
#set -o xtrace

ulimit -S -c 0      # Don't want coredumps.
set -o notify
set -o noclobber
set -o ignoreeof

# Enable options:
#shopt -s cdspell
#shopt -s cdable_vars
#shopt -s checkhash
#shopt -s sourcepath
#shopt -s no_empty_cmd_completion

# Disable options:
#shopt -u mailwarn
#unset MAILCHECK        # Don't want my shell to warn me of incoming mail.

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# append to the history file, don't overwrite it
shopt -s cmdhist
shopt -s histappend histreedit histverify
shopt -s histappend

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=2000

#export TIMEFORMAT=$'\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n'
#export HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S"
HISTIGNORE="&:bg:fg:ll:h"
HISTTIMEFORMAT="$(echo -e ${BCyan})[%Y-%m-%d %H:%M:%S]$(echo -e ${NC}) "
HOSTFILE=$HOME/.hosts                   # Put a list of remote hosts in ~/.hosts

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color)
        color_prompt=yes
    ;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
        # We have color support; assume it's compliant with Ecma-48
        # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
        # a case would tend to support setf rather than setaf.)
        color_prompt=yes
    else
        color_prompt=
    fi
fi

if [ "$color_prompt" = "yes" ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
    xterm* | rxvt*)
        PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;

    *)
    ;;
esac

##  ------------------------------------------------------------------------  ##
##                          Greeting, motd etc. ...                           ##
##  ------------------------------------------------------------------------  ##

##  Color definitions (taken from Color Bash Prompt HowTo).

# Normal Colors
Black='\e[0;30m'    # Black
Red='\e[0;31m'      # Red
Green='\e[0;32m'    # Green
Yellow='\e[0;33m'   # Yellow
Blue='\e[0;34m'     # Blue
Purple='\e[0;35m'   # Purple
Cyan='\e[0;36m'     # Cyan
White='\e[0;37m'    # White

# Bold
BBlack='\e[1;30m'   # Black
BRed='\e[1;31m'     # Red
BGreen='\e[1;32m'   # Green
BYellow='\e[1;33m'  # Yellow
BBlue='\e[1;34m'    # Blue
BPurple='\e[1;35m'  # Purple
BCyan='\e[1;36m'    # Cyan
BWhite='\e[1;37m'   # White

# Background
On_Black='\e[40m'   # Black
On_Red='\e[41m'     # Red
On_Green='\e[42m'   # Green
On_Yellow='\e[43m'  # Yellow
On_Blue='\e[44m'    # Blue
On_Purple='\e[45m'  # Purple
On_Cyan='\e[46m'    # Cyan
On_White='\e[47m'   # White

NC="\e[m"                   # Color Reset
ALERT=${BWhite}${On_Red}    # Bold White on red background

echo -e "\n\t${BCyan}This is ${BYellow}BASH ${BASH_VERSION%.*}${BCyan} \
on TTY ${NC}[${BYellow}$(tty)${NC}]\n"

##  ------------------------------------------------------------------------  ##
##                              Tailoring 'less'                              ##
##  ------------------------------------------------------------------------  ##

#export PAGER=less
#export LESSCHARSET='latin1'
#export LESSOPEN='|/usr/bin/lesspipe.sh %s 2>&-'
# Use this if lesspipe.sh exists.
#export LESS='-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \
#           :stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...'

##  LESS man page colors (makes Man pages more readable).
#export LESS_TERMCAP_mb=$'\E[01;31m'
#export LESS_TERMCAP_md=$'\E[01;31m'
#export LESS_TERMCAP_me=$'\E[0m'
#export LESS_TERMCAP_se=$'\E[0m'
#export LESS_TERMCAP_so=$'\E[01;44;33m'
#export LESS_TERMCAP_ue=$'\E[0m'
#export LESS_TERMCAP_us=$'\E[01;32m'

##  ------------------------------------------------------------------------  ##
##  Shell Prompt - for many examples, see:
##       http://www.debian-administration.org/articles/205
##       http://www.askapache.com/linux/bash-power-prompt.html
##       http://tldp.org/HOWTO/Bash-Prompt-HOWTO
##       https://github.com/nojhan/liquidprompt
##  ------------------------------------------------------------------------  ##
# Current Format: [TIME USER@HOST PWD] >
# TIME:
#    Green     == machine load is low
#    Orange    == machine load is medium
#    Red       == machine load is high
#    ALERT     == machine load is very high
# USER:
#    Cyan      == normal user
#    Orange    == SU to user
#    Red       == root
# HOST:
#    Cyan      == local session
#    Green     == secured remote connection (via ssh)
#    Red       == unsecured remote connection
# PWD:
#    Green     == more than 10% free disk space
#    Orange    == less than 10% free disk space
#    ALERT     == less than 5% free disk space
#    Red       == current user does not have write privileges
#    Cyan      == current filesystem is size zero (like /proc)
# >:
#    White     == no background or suspended jobs in this shell
#    Cyan      == at least one background job in this shell
#    Orange    == at least one suspended job in this shell
#
#    Command is added to the history file each time you hit enter,
#    so it's available to all shells (using 'history -a').


##  Test connection type:
if [ -n "${SSH_CONNECTION}" ]; then
    CNX=${Green}        # Connected on remote machine, via ssh (good).
elif [[ "${DISPLAY%%:0*}" != "" ]]; then
    CNX=${ALERT}        # Connected on remote machine, not via ssh (bad).
else
    CNX=${BCyan}        # Connected on local machine.
fi

##  Test user type:
if [[ ${USER} == "root" ]]; then
    SU=${Red}           # User is root.
elif [[ ${USER} != $(logname) ]]; then
    SU=${BRed}          # User is not login user.
else
    SU=${BCyan}         # User is normal (well ... most of us are).
fi


NCPU=$(grep -c 'processor' /proc/cpuinfo)   # Number of CPUs
SLOAD=$(( 100*${NCPU} ))                    # Small load
MLOAD=$(( 200*${NCPU} ))                    # Medium load
XLOAD=$(( 400*${NCPU} ))                    # Xlarge load


##  Adds some text in the terminal frame (if applicable).

##  Now we construct the prompt.
PROMPT_COMMAND="history -a"
#case ${TERM} in
#  *term | rxvt | linux)
#        # Time of day (with load info):
#        #PS1="\[\$(load_color)\][\A\[${NC}\] "
#        # User@Host (with connection type info):
#        #PS1=${PS1}"\[${SU}\]\u\[${NC}\]@\[${CNX}\]\h\[${NC}\] "
#        PS1="[\[${SU}\]\u\[${NC}\]@\[${CNX}\]\h\[${NC}\] "
#        # PWD (with 'disk space' info):
#        PS1=${PS1}"\[\$(disk_color)\]\W]\[${NC}\]: "
#        # Prompt (with 'job' info):
#        #PS1=${PS1}"\[\$(job_color)\]>\[${NC}\] "
#        # Set title of current xterm:
#        #PS1=${PS1}"\[\e]0;\][\u@\h] \w\a\]"
#        #PS1=${PS1}"\w\a\]"
#        ;;
#    *)
#        #PS1="(\A \u@\h \W) > " # --> PS1="(\A \u@\h \w) > "
#        PS1="(\A) : " # --> PS1="(\A \u@\h \w) > "
#                               # --> Shows full pathname of current dir.
#        ;;
#esac
